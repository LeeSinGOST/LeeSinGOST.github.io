---
title: 实现效果
date: 2023-07-08 24:25:09
updated: 2023-07-08 02:43:55
categories: 
	- 技术手册
tags: 
	- Emby
	- 追番
---
>截至发文仍在使用的追番模式，从部署流程来说还是比较繁琐的，当时也没怎么做功课，各个方面也存在很多优化空间，而且针对萌番组定制的，但鉴于是1.0方案和综合使用追了三四个季度番来说效果也不错，就笔记浅浅记录一下折腾流程。

# 实现效果

从[萌番组 (bangumi.moe)](https://bangumi.moe/)**订阅番剧**，然后就坐等服务器**下载**->**刮削**->**Emby**观看。

其余还实现了**RSS番剧更新**和**Aria2下载完成**的**QQ消息推送**，配合Emby弹幕观看，还是挺舒服的，本文先不讲这些。

# 意义

追番自由，蓝狗必备！

# 所需工具

### 运作载体：
云服务器：没有的话用自己电脑也行，问题不大。本文使用的是**Ubuntu 18**
			   云服务器的话可随时待机下载，随时随地不限设备登录 EMBY观看。

### 信息源
[萌番组](https://bangumi.moe/)：提供bt种子以及**番剧信息**，用到**RSS订阅**

### 软件
Flexget：**获取RSS更新**触发下载器自动下载，配置下载规则
Aria2：下载器，只管下
Python脚本：维护番剧库，将下载的番剧整理成EMBY能正确匹配的样子。
EMBY：在线刮削，海报墙和在线播放

>从工具上往下看，基本就知道运作流程了。

# 步骤

> 服务器这块就不说了，不讲究。

## Step 1 - 萌番组配置

> 突然想起萌番组被墙了些时日了，不过我是境外服务器也不耽误，境内的话估计要么代理要么反向代理。

1. **注册登录之后筛选订阅**，一通订阅之后如下图，因为涉及到空间和带宽流量，筛选尽可能的要细。

看看我的
![](images/91fc1e789b27e45235df893e541612a7.png)

2. **提取用户Cookie**

> 说明一下，按照正常来说本应不需要提取用户cookie，直接用个人订阅RSS即可获取所有订阅，后边在Flexget发现如果要实现每部番剧精细化管理，还是用每部番剧对应的RSS订阅比较好。
> 比如https://bangumi.moe/search/**615bb91fd7f73dd4ed5c4405**+**58a9c1e6f5dc363606ab42ed**，通过链接里加粗体的标签字符串，获取番剧详细信息，此处代替了本应连接tmdb获取的信息。

如图所示，在查看自己订阅信息的时候会加载出my的信息，复制右下处Cookie值备用，不过哪的cookie应该都一样，随便了。
![](images/c31e35a0ace45fd6b4f62d89aae706ac.png)

## Step 2 - Flexget配置

安装这块参考 [#教程#Aria2 rss订阅下载](https://www.locmjj.com/361.html)
以及文档 [Flexget 安装&配置](https://wiki.ukenn.top/seedbox-wiki-1/untitled-1)
注意要设置定时任务获取更新。
安装的坑 #有空再更新 ；；；

软件在这里用到的是动态配置文件，需要用脚本随时修改配置文件以跟上订阅项目更新。
更新配置文件的Python程序如下，写的有点糙，~~能跑就行~~，注释有空再说。~~后边如果有优化方案之后可能也不需要这个了~~
```py
#！/user/bin/python3
import requests

import json

url = 'https://bangumi.moe/'
mirror = 'https://bangumi.moe/'

headers = {
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36',
    'referer': 'https://bangumi.moe/',
    'Cookie': 'youcookie'  }         //填上你的Cookie!!!!!!!!!!!!!

def get_rss():

    rssurl= mirror + 'api/user/subscribe/collections'
    rss = requests.get(rssurl, headers=headers)
    rsstr= json.loads(rss.text)
    return rsstr




def get_name(rss):

    name = ''
    rssinfo= mirror + 'api/tag/fetch'
    data = {"_ids": rss}
    info = requests.post(rssinfo, json=data, headers=headers)
    infostr = json.loads(info.text)
    for i in range(0, len(infostr)):
        if infostr[i]['type'] == 'bangumi':
            names = infostr[i]['locale']
            if 'zh_cn' in names.keys():
                name = names['zh_cn']
            elif 'zh_tw' in names.keys():
                name = names['zh_tw']
            else:
                name = infostr[i]['name']
            return name
    return name

//下方主要修改Aria2相关的信息，包括secret密码,port端口，ip地址（此处本机），path番剧库路径，

def make_yml(rsstr, name):

    rej_reg = ["\'[cht\'", "\'720p\'", "\'720P\'" , "\'BIG\'"]
    in_aria2 = '      server: 127.0.0.1\n      port: 6800\n      secret: "123456"\n      path: "/root/aria2/bgmoe/'+name+'"\n\n'
    rss = mirror + 'rss/tags/' + '+'.join(rsstr)
    f = open('/root/.flexget/config.yml', 'a+', encoding = 'utf-8')
    f.writelines('  '+name+':\n')
    f.writelines('    rss: '+rss+'\n')
    f.writelines('    if:\n')
    for i in rej_reg:
        f.writelines('      - "' + i + ' in title": reject\n')
    f.writelines('      - "\'[\'": accept\n')
#    f.writelines('    accept_all: yes\n')
    f.writelines('    aria2:\n')
    f.writelines(in_aria2)
    f.close()

//这里也要注意一些path换成自己的
def main():
			//下面的path是检测的番剧库剩余空间容量，自行修改
    temp = 'templates:\n  gener:\n    free_space:\n      path: /root/aria2\n      space: 1024000\n'
    f = open('/root/.flexget/config.yml', 'w', encoding = 'utf-8')

    f.writelines('tasks: \n')
    f.close()
    rsstr = get_rss()
    for i in range(0, len(rsstr)):
        name = get_name(rsstr[i])
        if len(name) == 0 or len(rsstr) == 0:
            print("noname")
            continue
        print(name)
        make_yml(rsstr[i], name)
    f = open('/root/.flexget/config.yml', 'a+', encoding = 'utf-8')
    f.writelines('web_server:\n')
    f.writelines('  port: 8666\n')      //webui配置端口
    f.writelines('  web_ui: yes\n')
    f.writelines('schedules: no\n')
	f.close()
	
//以及全篇多处出现的配置文件路径，/root/.flexget/config.yml，默认跟我一样。

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(e)
```

由于flexget的一些特性，需要手动删除lock文件才能使用动态配置文件。故有下面脚本，更新配置直接运行下方脚本就行，不过也不用手动，后边要配置定时任务执行此脚本。

```sh
#! /bin/bash
#自行修改路径，此处py文件为上方py脚本
python3 /root/UpdateConfig.py 
#flexget默认安装路径
rm -f /root/.flexget/.config-lock
/usr/local/bin/flexget execute
```

## Step 3 - Aria2安装

建议一键脚本，直接一步到位。
[P3TERX/aria2.sh: Aria2 一键安装管理脚本 增强版 (github.com)](https://github.com/P3TERX/aria2.sh)
直接 wget -N git.io/aria2.sh && chmod +x aria2.sh
再运行脚本 ./aria2.sh

安装且配置好密钥之后需要在aria2安装目录自带的clean.sh脚本添加东西，该脚本会默认在下载任务结束后运行。
```sh
CHECK_CORE_FILE() {
    CORE_FILE="$(dirname $0)/core"
    if [[ -f "${CORE_FILE}" ]]; then
        . "${CORE_FILE}"
    else
        echo "!!! core file does not exist !!!"
        exit 1
    fi
}
#自定义
PUSHTOQQ(){

    /usr/bin/python3 /root/aria2/bgminfo.py;fi
}

CHECK_CORE_FILE "$@"
CHECK_PARAMETER "$@"
CHECK_FILE_NUM
CHECK_SCRIPT_CONF
GET_TASK_INFO
GET_DOWNLOAD_DIR
CONVERSION_PATH
#运行自定义
PUSHTOQQ                    
CLEAN_UP
exit 0
```

到这里基本就行了。记得回去更新UpdateConfig.py里的aria2信息。



> 可添加下载完删种脚本，以及下载完推送。

## Step 4 - py脚本维护番剧库

如果一切顺利的话，此时番剧库已经可以接受更新并分类下载进各自的文件夹了。此时为了能匹配EMBY所以还得写个脚本维护此库。
注释再说，能跑就行。。。
```py
#！/user/bin/python3
import os
import re
import sys
import json
import shutil

path = '/root/aria2/bgmoe/'
pattern0 = re.compile(r'Season (\d+)')
pattern1 = re.compile(r'\[(\d+)\]')
pattern2 = re.compile(r'\[(\d+)v')
pattern5 = re.compile(r'\[(\d+)集')
pattern3 = re.compile(r'第(\d+)話')
pattern4 = re.compile(r'S\d+E(\d+)')
pattern6 = re.compile(r'- (\d+) ')
patternlist = [pattern1, pattern2, pattern3, pattern4, pattern5, pattern6]

def find_ep(file):
    for pattern in patternlist:
        ep = re.findall(pattern, file)
        if len(ep) == 1:
            return int(ep[0])

    return -1


def find_maxep(path3):
    maxep = -1
    for root, dirs, files in os.walk(path3):
        for file in files:
            
            ep = find_ep(file)
            if ep > maxep:
                maxep = ep
            
    maxep = str(maxep).zfill(2)           
    return maxep

def find_season(path):
    maxss = 1
    for dir in os.listdir(path):
        if os.path.isfile(path+dir):
            continue
        seasonn = re.findall(pattern0, dir)
        if len(seasonn) == 1 and seasonn[0].isdigit() and int(seasonn[0]) > maxss:
            maxss = int(seasonn[0])
    season = str(maxss).zfill(2)
    return season

    

def rename(title, bgminfo):
    list1 = ['.mkv', '.MKV', '.mp4']
    season = bgminfo['season'].zfill(2)
    path2 = path + title + '/Season ' + season
    if not os.path.exists(path2):
        os.mkdir(path2)
    for file in os.listdir(path+title):
        if os.path.isdir(path+title+file):
            continue
        ext = os.path.splitext(file)[1]
        if ext in list1:
            ep = find_ep(file)
            if not ep == -1:
                desfile = title + ' - S' + season + 'E' + str(ep).zfill(2) +ext

                src = path+title+'/'+file
                des = path2+'/'+desfile
                try:
                    os.remove(des)
                except OSError:
                    pass
                
                print(src+ '------------>'+  des)
                shutil.move(src, des) 
    

def main():

    bgm_info = {}
    data = json.loads(json.dumps(bgm_info))
    for dir in os.listdir(path): 
        if os.path.isfile(path+dir):
            continue
            
        maxep = find_maxep(path+dir)
        info = {'title': dir, 'year': '', 'maxep': maxep, 'season': ''}
        if os.path.exists(path+'bgminfo.json'):                
            with open(path+'bgminfo.json','r') as g:
                bginfo = json.load(g)
                if not dir in bginfo:
                    season = find_season(path+dir)  
                    info['season'] = season
                    data[dir] = info
                    continue

                
                info['season'] = bginfo[dir]['season']

                if not bginfo[dir]['year'] == '':
                    info['year'] = bginfo[dir]['year']
               #     if not dir == newtitle:
                #        src = os.path.join(path, dir)
                 #       des = os.path.join(path, newtitle)
                  #      os.rename(src,des)
                   #     flag = 1
                    #    data[newtitle] = info
       # if not flag == 1:
        data[dir] = info
    print(data)
    result = json.dumps(data, ensure_ascii=False, indent=4)
    with open(path+'bgminfo.json', 'w', newline='\n') as f:
        f.write(result)
    for title in data:
        rename(title, data[title])



if __name__ == '__main__':
    main()
```

不出意外的话这是你的文件目录，脚本会自动生成json记录更新番剧信息。
![](images/0592bcf89f8c5d347e37f2c4f0ce3606.png)
以及
![](images/0defd78c49e62d570fef34945fb501c0.png)

## Step 5 - EMBY配置

ε=(´ο｀*)))唉，默认会了吧，安装之后把你的番剧库添加进媒体库就行了，其他等着自动扫描就行了，最多遇到点网络问题连不上tmdb，那个改改host就行。
上效果图吧
![](images/e9094d01c0d597f17ca0c093cb941c60.png)

# 缺点

1. 部署麻烦，逻辑也挺乱
2. 萌番组的cookie几个月会过期一次得手动更新
3. 萌番组有些字幕组的番剧标签上的有点随便，几个季度混在一起
4. 默认第一季，若不是第一季的话得手动去bgminfo.json修改季度信息
5. 绑定了萌番组