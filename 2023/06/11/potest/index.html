<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>potest | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习目的和学习方法好的算法对编程的意义  编写程序解决问题，所编写的程序就是算法。好的算法就是在解决同一个编程问题的情况下，可以更加的节约硬件资源，也就是说使计算速度更快。  目的  学会根据编程问题，设计一个好的算法，并且对设计的算法进行分析验证，是否为一个好的算法  算法的基本知识算法的理解和性质算法的理解  对于给定的问题， 1个计算机算法就是用计算机求解这个问题的方法．一般来说，算法 由有">
<meta property="og:type" content="article">
<meta property="og:title" content="potest">
<meta property="og:url" content="http://example.com/2023/06/11/potest/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="学习目的和学习方法好的算法对编程的意义  编写程序解决问题，所编写的程序就是算法。好的算法就是在解决同一个编程问题的情况下，可以更加的节约硬件资源，也就是说使计算速度更快。  目的  学会根据编程问题，设计一个好的算法，并且对设计的算法进行分析验证，是否为一个好的算法  算法的基本知识算法的理解和性质算法的理解  对于给定的问题， 1个计算机算法就是用计算机求解这个问题的方法．一般来说，算法 由有">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-06-11T07:34:03.000Z">
<meta property="article:modified_time" content="2023-06-11T07:41:58.975Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/06/11/potest/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'potest',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-11 15:41:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">potest</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-11T07:34:03.000Z" title="Created 2023-06-11 15:34:03">2023-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-11T07:41:58.975Z" title="Updated 2023-06-11 15:41:58">2023-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="potest"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="学习目的和学习方法"><a href="#学习目的和学习方法" class="headerlink" title="学习目的和学习方法"></a>学习目的和学习方法</h1><p>好的算法对编程的意义</p>
<blockquote>
<p>编写程序解决问题，所编写的程序就是算法。好的算法就是在解决同一个编程问题的情况下，可以更加的节约硬件资源，也就是说使计算速度更快。</p>
</blockquote>
<p>目的</p>
<blockquote>
<p>学会根据编程问题，设计一个好的算法，并且对设计的算法进行分析验证，是否为一个好的算法</p>
</blockquote>
<h1 id="算法的基本知识"><a href="#算法的基本知识" class="headerlink" title="算法的基本知识"></a>算法的基本知识</h1><h2 id="算法的理解和性质"><a href="#算法的理解和性质" class="headerlink" title="算法的理解和性质"></a>算法的理解和性质</h2><p>算法的理解</p>
<blockquote>
<p>对于给定的问题， 1个计算机算法就是用计算机求解这个问题的方法．一般来说，算法 由有限条指令构成，每条指令规定了计算机所要执行的有限次运算或者操作．</p>
</blockquote>
<p>算法的性质</p>
<blockquote>
<p>主要有有穷性、确定性、可行性</p>
<p>有穷性<br>算法必须在有限个计算步骤后终止</p>
<p>确定性<br>算法必须是没有歧义的</p>
<p>可行性<br>每一个动作都能够被精准地机械执行</p>
</blockquote>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><h3 id="伪码的基础知识"><a href="#伪码的基础知识" class="headerlink" title="伪码的基础知识"></a>伪码的基础知识</h3><p>伪代码的理解</p>
<blockquote>
<p>伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言(Pascal, C, Java, etc)实现。因此，伪代码必须结构清晰，代码简单，可读性好，并且类似自然语言。</p>
</blockquote>
<h3 id="伪码的表示"><a href="#伪码的表示" class="headerlink" title="伪码的表示"></a>伪码的表示</h3><p>算法伪码描述</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image003.jpg"></p>
</blockquote>
<p>伪码里的变量声明</p>
<blockquote>
<p>变量不需声明，但都相当于是所在函数内部的局部变量，不能不加显示的说明就使用全局变量；</p>
</blockquote>
<p>伪代码里的程序块的理解</p>
<blockquote>
<p>伪代码用缩进表示程序块 。<br>表示程序中的分支程序结构，同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进；</p>
</blockquote>
<p>伪码的常用运算符</p>
<blockquote>
<p><code>算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符=,≠,&lt;,≤和≥，以及逻辑运算符与(and),或（or），非（not）。</code></p>
</blockquote>
<p>伪码里的mod运算符</p>
<blockquote>
<p>MOD，是一个数学运算符号。a mod b&#x3D;c，表明a除以b余数为c</p>
</blockquote>
<p>赋值语句的伪码表示</p>
<blockquote>
<p>赋值语句用符号←表示，x←exp表示将exp的值赋给x，其中x是一个变量，exp是一个与x同类型的变量或表达式（该表达式的结果与x同类型）；多重赋值i←j←e是将表达式e的值赋给变量i和j，这种表示与j←e和i←e等价。</p>
</blockquote>
<p>内容交换的伪码表示</p>
<blockquote>
<p>若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。</p>
</blockquote>
<p>数组的伪码表示</p>
<blockquote>
<p>A[j]指示数组A的第j个元素。符号“ …”用来指示数组中值的范围。例如：<br>A[1…j]表示含元素A[1], A[2], … , A[j]的子数组；</p>
</blockquote>
<p>注释的伪代码表示</p>
<blockquote>
<p>因为伪代码属于类C语言，所以注释采用C语言中的 “&#x2F;&#x2F; ”</p>
</blockquote>
<p>输出语句的伪码表示</p>
<blockquote>
<p>输出出语句由关键字return后面跟随着输出变量或函数值等构成.当在循环体内遇到输出语句时,不管是否满足循环的条件,算法将停止进一步的迭代,立刻进行输出,然后算法停止运行.</p>
</blockquote>
<h3 id="伪代码的if语句"><a href="#伪代码的if语句" class="headerlink" title="伪代码的if语句"></a>伪代码的if语句</h3><p>形式1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if c</span><br><span class="line">then s</span><br><span class="line">//C是逻辑表达式，S是执行语句</span><br></pre></td></tr></table></figure>



<p>形式2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if c</span><br><span class="line">then S1</span><br><span class="line">	 S2</span><br><span class="line">else S3</span><br><span class="line">	 S4</span><br><span class="line">	</span><br><span class="line">//如果在一个if语句的一个选项里，有很多执行语句，比如形式2的第一个if选项 有S1,S2，可以把S2缩进的写在下一行表示。表示与S1一样，都是then后的执行语句。没有缩进的写在下一行，则表示不是if的执行语句，而是其他语句。 既缩进可以表示同一个程序块</span><br></pre></td></tr></table></figure>




<p>形式3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if C</span><br><span class="line"></span><br><span class="line">then S</span><br><span class="line"></span><br><span class="line">else if C2</span><br><span class="line"></span><br><span class="line">then  S2</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">else Sn</span><br></pre></td></tr></table></figure>




<h3 id="伪代码的whie语句"><a href="#伪代码的whie语句" class="headerlink" title="伪代码的whie语句"></a>伪代码的whie语句</h3><p>形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while c do</span><br><span class="line">	S1</span><br><span class="line">	S2</span><br><span class="line">S3</span><br><span class="line">//C是逻辑表达式。S是执行语句，且while里的语句得用缩进表示。当C为真执行 S1 S2。C为假的时候，执行S3</span><br></pre></td></tr></table></figure>






<h3 id="伪代码的for语句"><a href="#伪代码的for语句" class="headerlink" title="伪代码的for语句"></a>伪代码的for语句</h3><p>形式1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for i&lt;-0 to 1 do</span><br><span class="line">	S1</span><br><span class="line">	S2</span><br><span class="line"></span><br><span class="line">//相当于C++</span><br><span class="line">for(i=0;i＜=1;i++)</span><br><span class="line">&#123;</span><br><span class="line">	S1;</span><br><span class="line">	S2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>形式1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i&lt;-n to 0 do</span><br><span class="line">	S1</span><br><span class="line">	S2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="时间复杂度的基础知识"><a href="#时间复杂度的基础知识" class="headerlink" title="时间复杂度的基础知识"></a>时间复杂度的基础知识</h3><p>时间复杂度的理解</p>
<blockquote>
<p>时间复杂度是用来描述算法运行时间、运行规模的一个式子<br>时间复杂度越高，算法运行时间规模更大</p>
<p>可以理解把时间复杂度看成是评估一个算法运行时间的单位。<br>比如人睡觉是以小时为单位，烧一壶水是以分钟单位，飞船从地球飞出太阳系是以年为单位。通过这件事的时间单位，我们就可以大概知道这件事的时间规模。同理时间复杂度可以看成，算法运行时间的单位，我们可以通过时间复杂度知道大概的运行时间规模。</p>
</blockquote>
<p>问题规模</p>
<blockquote>
<p>算法的问题规模通常是指算法需要处理的问题的输入数据的大小或数量。这个问题规模可以用各种不同的度量方式来表示，比如输入数据的长度、元素个数、矩阵的行数和列数等等，具体取决于具体的算法和问题。</p>
</blockquote>
<p>问题规模和时间复杂度的关系</p>
<blockquote>
<p>在算法分析中，问题规模通常被用来估计算法的时间复杂度和空间复杂度。时间复杂度描述了算法运行所需的时间量，而空间复杂度描述了算法在执行期间需要使用的内存量。通常来说，随着问题规模的增加，算法的时间和空间复杂度也会相应增加。</p>
</blockquote>
<p>常见时间复杂度和其比较</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image004.jpg"></p>
</blockquote>
<h3 id="时间复杂度的计算规定"><a href="#时间复杂度的计算规定" class="headerlink" title="时间复杂度的计算规定"></a>时间复杂度的计算规定</h3><p>一次基础操作的时间复杂度用<code>O(1)</code>表示</p>
<blockquote>
<p>一次加、减、乘、除、打印这种基本的操作，可以认为计算机的执行次数为1，则的时间复杂度用<code>O(1)</code>表示。举例如下<br>![[Pasted image 20230414014304.png]]<br>代码是一次打印操作，可以认为计算机的行次数为1则的时间复杂度用<code>O(1)</code>表示。</p>
</blockquote>
<p>只取最高次数的n作为时间复杂度。</p>
<blockquote>
<p>例子1<br>![[Pasted image 20230414014428.png]]<br>其时间复杂度为<code>O(n)</code><br>例子循环执行（n-i）次循环的操作，每一次操作都是<code>O(1)</code>，也就是说原本时间复杂度应该为<code>（n-i）*O(1)</code>&#x3D;<code>O(n-i)</code><br>但是时间复杂度不是<code>O(n-i)</code>，而是<code>O(n)</code>，我们只取最高次数的n作为时间复杂度，i可以看为<code>i*n的0次方。</code></p>
<p>例子2<br>![[Pasted image 20230414015452.png]]<br>其时间复杂度为<code>O（n^2）</code><br>例子循环执行(n-i)(n-j)次操作,最高次为n^2，我们只取最高次数的n因此我们用<code>O(n^2)</code>表示</p>
<p>例子3<br>![[Pasted image 20230414015727.png]]<br>其时间复杂度为<code>O（n^3）</code></p>
</blockquote>
<p>只取最高次数的n作为时间复杂度的原因</p>
<blockquote>
<p>以生活为例，我们更常说说睡一觉是几小时，而不会说睡一觉是几小时零几分。   所以在同一个算法当中 ，有多个时间复杂度相加，我们只取次数最大的那一个。</p>
</blockquote>
<p>时间复杂度的常数系数为1 </p>
<blockquote>
<p>例子<br>![[Pasted image 20230414015855.png]]<br>其时间复杂度为<code>O(1)</code><br>3次基础操作，每次操作的时间复杂度<code>O(1)</code><br>就是说原本时间复杂度应该为3*<code>O(1)</code>&#x3D;<code>O(3)</code>，而由于规定，时间复杂度的常数系数为1，所以只能其时间复杂度只能是<code>O(1)</code></p>
</blockquote>
<p>时间复杂度的常数系数为1的原因</p>
<blockquote>
<p>之前说过时间复杂度可以理解为是评估一个算法运行时间的单位  ，<code>O(1)</code>就是表示执行基本操作的运行时间单位。而在生活中，我们说烧一壶水所花费的时间是几分钟，却不会说烧两壶水是两个几分钟，而也是用几分钟表示烧两壶水。所以在同一个算法当中，有多个相同的时间复杂度，不能把这些时间复杂度加起来，以此来合并系数，而是应该只用其中一个表示该算法时间复杂度</p>
</blockquote>
<p>时间复杂度<code>O(1)</code>的理解</p>
<blockquote>
<p>在上面的规定下，时间复杂度的<code>O(1)</code>表示算法的运行时间是一个常数。也就是说，无论输入数据的规模如何增加，算法的执行时间都不会改变，始终为一个固定的值。</p>
</blockquote>
<h3 id="时间复杂度的计算方式"><a href="#时间复杂度的计算方式" class="headerlink" title="时间复杂度的计算方式"></a>时间复杂度的计算方式</h3><p>时间复杂度的计算方式的总结</p>
<blockquote>
<p>先计算大概运行多少次，以为n的式子表示。<br>然后让式子常数系数都为1<br>只取最高次数的n。</p>
</blockquote>
<p>快速判断一个算法的时间复杂度的方法</p>
<blockquote>
</blockquote>
<p>快速判断一个算法的时间复杂度<br>确定问题规模n<br>一般k层关于n的循环，都是O（n的k次方）<br>问题规模减半都是O（logn）</p>
<p>举例1</p>
<blockquote>
<p>![[Pasted image 20230414020824.png]]<br>时间复杂度为<code>O(n^2)</code></p>
</blockquote>
<p>举例2</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image007.jpg"></p>
</blockquote>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度的理解</p>
<blockquote>
<p>空间复杂度是描述了算法在执行期间需要使用的内存量的式子。</p>
</blockquote>
<p>常见空间复杂度</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image008.jpg"><br>当递归深度为 d 时，递归函数的空间复杂度为 O(d)，即需要 d 个栈帧来保存每次函数调用的相关信息。因此，在设计递归函数时，需要注意控制递归深度，避免出现栈溢出等问题。</p>
</blockquote>
<p>算法的规则</p>
<blockquote>
<p>大部分算法有一个规则，空间换时间，我这个算法宁愿占用更多内存，也要尽量的运行时间更快。（时间比内存值钱。）</p>
</blockquote>
<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>递归算法组成</p>
<blockquote>
<p>结束条件<br>调用自身</p>
</blockquote>
<p>怎么去看懂递归函数</p>
<blockquote>
<p>要用宏观的思维，整体的思维去理解，不要用陷入每次递归的具体细节。<br>也就是说在写递归函数的，只需要思考递归函数，要传入什么值，然后获得什么效果，以此来写递归过程，然后最终考虑结束条件即可。<br>总的来说分为三步</p>
<ol>
<li>看结束条件：递归算法中必须有一个基本情况，它不需要再次递归调用自身，并且可以直接得出结果。因此，快速看懂一个递归算法的关键是要通过结束条件找出这个基本情况。</li>
<li>确定递归调用：在基本情况之外，递归算法必须调用自身来解决子问题。因此，需要理解递归调用的方式和参数传递的方式。</li>
<li>确定返回值：递归算法中必须确定正确的返回值，以便最终得到正确的解决方案。在递归调用结束后，需要将结果合并或处理成最终的结果。</li>
</ol>
</blockquote>
<p>递归函数的判断举例</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image009.jpg"><br>func1 不是递归算法，因为没有结束条件<br>func2不是递归算法，因为没有结束条件<br>func3是递归算法.如果传入3，则输出3 2 1<br>func4是递归算法.如果传入3，则输出1 2 3</p>
</blockquote>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找基本知识"><a href="#查找基本知识" class="headerlink" title="查找基本知识"></a>查找基本知识</h2><p>查找</p>
<blockquote>
<p>在算法中，查找是指在一个数据集合中查找一个特定的元素或值。好的查找算法能更快的查找到所需要的元素或值，从而提高代码的运行效率。</p>
</blockquote>
<p>查找的输入输出</p>
<blockquote>
<p>从列表中查找指定元素。<br>输入:列表、待查找元素。<br>输出︰元素下标(未找到元素时一般返回None或-1)</p>
</blockquote>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><h3 id="顺序查找的基本知识"><a href="#顺序查找的基本知识" class="headerlink" title="顺序查找的基本知识"></a>顺序查找的基本知识</h3><p>顺序查找的理解</p>
<blockquote>
<p>也叫线性查找，从列表第一个元素开始，顺序进行搜索,直到找到元素或搜索到列表最后一个元素为止。</p>
</blockquote>
<h3 id="顺序查找的实现"><a href="#顺序查找的实现" class="headerlink" title="顺序查找的实现"></a>顺序查找的实现</h3><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//顺序查找的函数，a是要查的列表，n是列表长度，x是要查找的值，返回值是查找的值的下标。</span><br><span class="line">int SequentialSearch(int *a,const int n, const int x);</span><br><span class="line"></span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int m[] = &#123;2,4,6,8,0,1,3,5,7,9&#125;;</span><br><span class="line"></span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	int num = 7;</span><br><span class="line"></span><br><span class="line">	result = SequentialSearch(m,10,num);</span><br><span class="line"></span><br><span class="line">	if(result==-1) cout&lt;&lt;&quot;没找到！&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	else cout&lt;&lt;&quot;在m[&quot;&lt;&lt;result&lt;&lt;&quot;]里找到&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顺序查找函数的实现</span><br><span class="line">int SequentialSearch(int *a,const int n, const int x)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	//循环n次查找num</span><br><span class="line"></span><br><span class="line">	for(i = 0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		if(a[i]==x)</span><br><span class="line"></span><br><span class="line">		return i;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">if(i==n) return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">时间复杂度为O（n）</span><br></pre></td></tr></table></figure>


<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找的基本知识"><a href="#二分查找的基本知识" class="headerlink" title="二分查找的基本知识"></a>二分查找的基本知识</h3><p>二分查找的理解</p>
<blockquote>
<p>假设有一段单调递增序列。<br>取序列数据的中间值 A ，将 A 与要找的值 X 作比较，然后，<br>if(A &#x3D;&#x3D; X)  查找完毕,获取查找的值的下标；<br>else if(A &lt; X) ，就将单调序列的前一半舍去，以 A 为单调序列起点，重复取序列中间站操作；<br>else if(A &gt; X) ，就将单调序列的后一半舍去，以 A 为单调序列终点，重复取序列中间站操作；</p>
</blockquote>
<p>二分查找查找列表中实数3的举例</p>
<blockquote>
<p>![[Pasted image 20230414141847.png]]<br>假设有一个单调递增序列，如上图，中间两个数字先暂时隐藏。<br>left为数组下标 0<br>right为数组下标n-1&#x3D;8</p>
<p>![[Pasted image 20230414142045.png]]<br>mid为中间值下标<br>mid&#x3D;(left+right)&#x2F;2&#x3D;4.<br>得到中间值的下标4，中间值为5。 5&gt;3,右边舍去留下左边候选区。</p>
<p>![[Pasted image 20230414142331.png]]<br>right&#x3D;mid-1&#x3D;3</p>
<p>![[Pasted image 20230414142420.png]]<br>mid&#x3D;(left+right)&#x2F;2&#x3D;1<br>得到中间值下标1，中间值为2。 2&lt;3,舍去左边，留下右边的候选区</p>
<p>![[Pasted image 20230414142508.png]]<br>left&#x3D;mid+1&#x3D;2</p>
<p>![[Pasted image 20230414142632.png]]<br>假设列表的值如上图，此时可以正常查到要查的值。<br>mid&#x3D;(left+right)&#x2F;2&#x3D;2<br>得到中间值下标2，中间值为 3，则找列表中实数3的下标为2.</p>
<p>![[Pasted image 20230414143908.png]]<br>假设列表值如上图，此时可以无法查到要查的值。<br>mid&#x3D;(left+right)&#x2F;2&#x3D;2<br>得到中间值下标2，中间值为 4，3&lt;4，此时right＝mid-1&#x3D;1。然后left&gt;right则表示列表无查找的值。<br>所以该算法判定是否有无查找的值的条件就是，left&gt;right，代表此时已经无候选区了</p>
<p>![[Pasted image 20230414143738.png]]<br>假设列表值如上图，mid&#x3D;(left+right)&#x2F;2&#x3D;2.<br>得到中间值下标2，中间值为 2，2&lt;3，此时left＝mid+1&#x3D;3.<br>left&#x3D;right.&#x3D;3.再取mid&#x3D;(left+right)&#x2F;2&#x3D;3，得到中间值下标3，中间值为 3，则找列表中实数3的下标为3.</p>
</blockquote>
<h3 id="二分查找的实现"><a href="#二分查找的实现" class="headerlink" title="二分查找的实现"></a>二分查找的实现</h3><p>二分查找代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int erfenchazhao(int *a,const int n, const int x);//二分查找函数，a是列表，n是列表长度，x是要查找的值，返回值是查找的下标。没有查到则返回-1</span><br><span class="line"></span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//查找列表</span><br><span class="line">	int m[] = &#123;0,1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">	</span><br><span class="line">	//查找结果</span><br><span class="line">	int result;</span><br><span class="line"></span><br><span class="line">	//查找的值</span><br><span class="line">	int num=3;</span><br><span class="line">	</span><br><span class="line">	result = erfenchazhao(m,9,num);</span><br><span class="line">	</span><br><span class="line">	if(result==-1) cout&lt;&lt;&quot;没找到！&quot;&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;在m[&quot;&lt;&lt;result&lt;&lt;&quot;]里找到&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找函数的实现</span><br><span class="line">int erfenchazhao(int *a,const int n, const int x)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int left=0;</span><br><span class="line">	int right=n-1;</span><br><span class="line">	int mid;</span><br><span class="line">	</span><br><span class="line">	//表示此时仍然有候选区，可以继续算法</span><br><span class="line">	while(left&lt;=right)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(left+right)/2;</span><br><span class="line">		if(a[mid]==x)</span><br><span class="line">		&#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(a[mid]&lt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			left=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(a[mid]&gt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			right=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>算法时间复杂度</p>
<blockquote>
<p>时间复杂度为<code>O(logn)</code><br>跟顺序查找对比<br>如果列表是有序的，就用二分查找，<br>如果列表是无序的推荐用顺序查找，也可队列表进行排序，然后用二分查找。</p>
</blockquote>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序的基本知识"><a href="#排序的基本知识" class="headerlink" title="排序的基本知识"></a>排序的基本知识</h2><p>排序的理解</p>
<blockquote>
<p>将一组“无序”的记录序列调整为“有序”的记录序列。</p>
</blockquote>
<p>列表排序的输入输出</p>
<blockquote>
<p>将无序列表变为有序列表。<br>输入:列表。<br>输出:有序列表</p>
</blockquote>
<p>常见排序及其分类</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image018.jpg"></p>
</blockquote>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡排序的基础知识"><a href="#冒泡排序的基础知识" class="headerlink" title="冒泡排序的基础知识"></a>冒泡排序的基础知识</h3><p>冒泡排序的思想（理解）</p>
<blockquote>
<p>（冒泡排序排列从小到大的时候）<br>对列表进行冒泡排序，在每一轮排序里，从表头开始，依次让相邻的元素进行比较，如果前一个比后一个大则交换，最终让最大的元素移至列表尾部。以此类推，通过一轮轮排序，使整个整个列表都被排序好。</p>
<p>具体的说明，通过第一轮排序能找出最大的元素，并使最大的元素移至列表最后一位，然后通过第二轮排序使次大的元素移至列表倒数第二位，以此类推，直至所有元素有序。</p>
</blockquote>
<p>冒泡排序的举例</p>
<blockquote>
<p>假设待排序序列为 (5,1,4,2,8)，采用冒泡排序对其进行升序（由小到大）排序</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image019.jpg">第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图所示。<br>第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部并入已排序序列中。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image020.jpg">第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置。<br>经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image021.jpg"> 第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置。<br>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image022.jpg">第四轮排序，此时待排序序列包含前 2 个元素，经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image023.gif">进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列。<br>一共5个数，举行5-1轮排序。</p>
</blockquote>
<h3 id="冒泡排序的实现"><a href="#冒泡排序的实现" class="headerlink" title="冒泡排序的实现"></a>冒泡排序的实现</h3><p>冒泡排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//冒泡排序函数</span><br><span class="line">void mppx(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //第一层循环，每经历第一层循环，就找最大的一个数字放在最右边.列表里有n个数，则一共要经历n-1轮</span><br><span class="line">    for (int i = 1; i &lt;= n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //第二层循环，每经历一次循环，就表示有一对相邻的数进行比较交换。</span><br><span class="line">        //n-i表示当前可以交换的数的最大下标，n-i-1表示可以交换的最大数的前一个数的下标</span><br><span class="line">        for (int j = 0; j &lt;= n - i - 1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[j] &lt; a[j + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                int temp = a[j + 1];</span><br><span class="line">                a[j + 1] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10001];</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">	//输入要排序的数组序列</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>冒泡排序的时间复杂度</p>
<blockquote>
<p>冒泡排序一共要进行(n-1)轮排序，第一轮排序(n-1),第二轮排序(n-2),直到最后一轮排序1次。<br>所以一共的比较次数是:<br>(n-1) + (n-2) + (n-3) + … + 1 &#x3D; n*(n-1)&#x2F;2;<br>所以冒泡排序的时间复杂度是 O(n平方)</p>
</blockquote>
<p>冒泡排序的空间复杂度</p>
<blockquote>
<p><code>O(1)</code></p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序的基础知识"><a href="#选择排序的基础知识" class="headerlink" title="选择排序的基础知识"></a>选择排序的基础知识</h3><p>选择排序的思想（理解）</p>
<blockquote>
<p>对列表进行选择排序，在每一轮排序里，选择未排序列的最小的元素，放到已排序序列的末尾。以此类推，通过一轮轮排序，使整个整个列表都被排序好。</p>
<p>具体的说明，第一轮排序里，在待排序记录r[1]<del>r[n]中选出最小的记录，将它与r[1]交换，此时r[1]是已排序序列， 待排序记录为r[2]</del>r[n]  ；第二轮排序里，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换，此时r[1]r[2]是已排序序列；以此类推，直到全部排序完成</p>
</blockquote>
<p>选择排序的举例说明</p>
<blockquote>
<p>初始序列：{2 4 7 1 6 9 8 3 0 5} 　　<br>第1趟：2与0交换：0{4 7 1 6 9 8 3 2 5} 　　<br>第2趟：0不动,4与1交换：0 1{7 4 6 9 8 3 2 5} 　　<br>第3趟：7与2交换：0 1 2{4 6 9 8 3 7 5} 　　<br>第4趟：4与3交换：0 1 2 3{6 9 8 4 7 5} 　　<br>第5趟：6与4交换：0 1 2 3 4{9 8 6 7 5}<br>第6趟：9与5交换：0 1 2 3 4 5{8 6 7 9}<br>第7趟：8与6交换：0 1 2 3 4 5 6{8 7 9}<br>第8趟：8与7交换：0 1 2 3 4 5 6 7{8 9}<br>第9趟：排序完成</p>
</blockquote>
<h3 id="选择排序的实现"><a href="#选择排序的实现" class="headerlink" title="选择排序的实现"></a>选择排序的实现</h3><p>选择排序的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//选择排序函数</span><br><span class="line">// a是传入的数组序列，n是数组里的存储的数量</span><br><span class="line">void xzpx(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //第一层循环，每经历第一层循环，就找最小的一个数字放在最左边，列表n个数只需要n-1轮循环即可</span><br><span class="line">    for (int i = 1; i &lt;= n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //存储找到的未排序列最小的值，暂存未排序列的第一个元素</span><br><span class="line">        int temp = a[i - 1];</span><br><span class="line">        //存储找到未排序列最小的值的下标，暂存第一个元素的下标</span><br><span class="line"></span><br><span class="line">        int jl = i - 1;</span><br><span class="line"></span><br><span class="line">        //第二层循环，每经历一次循环，就有一次对比，未排序列表有10个数就要对比9次。通过这次循环找到现有未排序列最小值存储到temp，下标存储到jl；</span><br><span class="line"></span><br><span class="line">        for (int j = i; j &lt;= n - 1; j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (temp &gt; a[j])</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                temp = a[j];</span><br><span class="line"></span><br><span class="line">                jl = j;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将找到的最小的值，与未排序列的第一个值的位置交换，这时该位置就是属于已排序列</span><br><span class="line"></span><br><span class="line">        a[jl] = a[i - 1];</span><br><span class="line"></span><br><span class="line">        a[i - 1] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a[10001];</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    //输入要排序的数组序列</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对数组序列进行从大到小的选择排序_</span><br><span class="line"></span><br><span class="line">    xzpx(a, n);</span><br><span class="line">    //对排序后的数组进行输出_</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>选择排序的时间复杂度</p>
<blockquote>
<p>待排序列表r,列表长度为n, 每次循环从待排序列表中，找到最小的值。所以一共经历(n-1次循环)<br>第一次循环，r[0]得和(n-1)个数进行对比，r[2]得和（n-2）个数进行对比，直到最后一次循环，r[n-2]，只和最后一个数进行对比，则时间复杂度为(n-1) + (n-2) + (n-3) + … + 1 &#x3D; n*(n-1)&#x2F;2;<br>所以<code>O(n^2)</code></p>
</blockquote>
<p>选择排序空间复杂度</p>
<blockquote>
<p><code>O(1)</code></p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序的基础知识"><a href="#插入排序的基础知识" class="headerlink" title="插入排序的基础知识"></a>插入排序的基础知识</h3><p>插入排序的思想（理解）</p>
<blockquote>
<p>对列表进行插入排序，在每一轮排序里，将一个待排序列的元素，按其值大小插入到已排序列里的适当位置上去。以此类推，通过一轮轮排序，使整个整个列表都被排序好。</p>
<p>具体说明：<br>首先默认列表第一个元素是已排序列，然后在第一轮排序里，将待排序列里的一个数，一般是第一个数，在已排序序列中从后向前扫描对比（也就是大到小扫描对比），找到相应位置并插入。<br>之后的每一轮排序里都将一个待排序的元素，在已排序序列中从后向前扫描对比，按其值大小插入到前面已排序里的适当位置上去，直到全部排序完成</p>
</blockquote>
<p>插入排序的举例说明</p>
<blockquote>
<p>对一组序列（9，3，1，4，2，7，8，6，5）用插入排序从小到大进行排序</p>
<p>首先<br>先把待排序序列第一个元素9，直接当做已排序序列，放在已排序序列。<br>此时已排序序列为（9），待排序序列为（3，1，4，2，7，8，6，5）<br>然后如下图进行排序。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image024.jpg">每步将一个待排序的元素，按其值大小插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止</p>
<p>在正式代码里，为了减少内存的使用，就不会建立两个表来区分待排序列表和未排序列表，待排序列表和未排序列表都会统一放在同一个列表内来进行插入排序。</p>
</blockquote>
<h3 id="插入排序的实现"><a href="#插入排序的实现" class="headerlink" title="插入排序的实现"></a>插入排序的实现</h3><p>插入排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//插入排序函数 </span><br><span class="line">void crpx(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	//第一层循环，每次循环就将一个待排序的一个值插入到已排序的序列里，一共进行(n-1)轮排序。i是待排序的下标</span><br><span class="line">	for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//待排序元素</span><br><span class="line">		int temp=a[i];</span><br><span class="line"></span><br><span class="line">		//第二层循环，每次循环最开始，j是已排的序列的最大值的下标</span><br><span class="line">		int j=i-1;</span><br><span class="line">		for(;j&gt;=0;)</span><br><span class="line">		&#123;	</span><br><span class="line">			if(temp&lt;a[j])</span><br><span class="line">			&#123;	</span><br><span class="line">				a[j+1]=a[j];j--;</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			&#125; </span><br><span class="line">			else if(temp&gt;=a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				break;	</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+1]=temp;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[10001]; </span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	//输入要排序的数组序列 </span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	//对数组序列进行从大到小的插入排序 </span><br><span class="line">	crpx(a,n);</span><br><span class="line">	</span><br><span class="line">	//对排序后的数组进行输出 </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">代码说明</span><br><span class="line">输入5</span><br><span class="line">3 7 1 8 5</span><br><span class="line">排序过程</span><br><span class="line">以上面的例子来说排序的对象是 3，7，1，8，5 数组长度为5，因为第一个元素看做一个有序序列  ，所以for循环的次数是：5（数组长度） - 1 = 4, 每次循环就将一个待排序的一个值插入到已排序的序列里，</span><br><span class="line">第一轮for循环</span><br><span class="line">列表：3 7 1 8 5</span><br><span class="line">3&gt;7不成立，插入待排序元素，列表为3 7 1 8 5，此时有序序列为3，7</span><br><span class="line"></span><br><span class="line">第二轮for循环</span><br><span class="line">列表：3 7 1 8 5</span><br><span class="line">7&gt;1成立，数组变成3，7，7，8，5</span><br><span class="line">3&gt;1成立，数组变成3，3，7，8，5</span><br><span class="line">插入待排序元素，此时列表为1，3，7，8，5，有序序列为1，3，7</span><br><span class="line"></span><br><span class="line">第三次for循环</span><br><span class="line">列表：1，3，7，8，5，</span><br><span class="line">7&gt;8不成立，插入待排序元素，列表为1，3，7，8，5此时有序序列为1，3，7，8</span><br><span class="line"> </span><br><span class="line">第四次for循环</span><br><span class="line">列表：1，3，7，8，5</span><br><span class="line">8&gt;5成立，数组变成1，3，7，8，8</span><br><span class="line">7&gt;5成立，数组变成1，3，7，7，8</span><br><span class="line">3&gt;5不成立，插入待排序元素，此时数组为1，3，5，7，8，有序序列为1，3，5，7，8，排序完成</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


<p>时间复杂度</p>
<blockquote>
<p>一共经历(n-1)次轮循环。第一轮循环最多对比一次，第2轮循环最多对比2次，第(n-1)循环最多对比n-1次<br>(n-1) + (n-2) + (n-3) + … + 1 &#x3D; n*(n-1)&#x2F;2;<br>O(n^2)</p>
</blockquote>
<p>空间复杂度</p>
<blockquote>
<p><code>O(1)</code></p>
</blockquote>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="归位操作"><a href="#归位操作" class="headerlink" title="归位操作"></a>归位操作</h3><p>归位操作的具体实现过程</p>
<blockquote>
<p>![[Pasted image 20230415033033.png]]<br>设置两个指针 low 和 high，分别指向无序表的表头和表尾。先由 high 指针从右往左依次遍历，直到找到一个比 49 小的关键字，所以 high 指针走到 27 的地方停止。找到之后将该关键字同 low 指向的关键字进行互换</p>
<p>![[Pasted image 20230415033046.png]]<br>然后指针 low 从左往右依次遍历，直到找到一个比 49 大的关键字为止，所以 low 指针走到 65 的地方停止。同样找到后同 high 指向的关键字进行互换：</p>
<p>![[Pasted image 20230415033152.png]]<br>指针 high 继续左移，到 13 所在的位置停止（13&lt;49），然后同 low 指向的关键字进行互换</p>
<p>![[Pasted image 20230415033203.png]]<br>指针 low 继续右移，到 97 所在的位置停止（97&gt;49），然后同 high 指向的关键字互换位置</p>
<p>![[Pasted image 20230415033215.png]]<br>指针 high 继续左移，此时两指针相遇，整个过程结束；</p>
</blockquote>
<p>归位函数的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//归位操作的函数，L是列表，left和right分别是表左和表右的下标</span><br><span class="line">int Partition(int *L,int left,int right) </span><br><span class="line">&#123;</span><br><span class="line">	int temp= L[left];</span><br><span class="line">	while(left&lt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		while(L[right]&gt;=temp&amp;&amp;left&lt;right)//这个循环找右边比temp小的数 </span><br><span class="line">		&#123;</span><br><span class="line">			right=right-1; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//找到后右边的值换到左边来，左边的值换到右边来 </span><br><span class="line">		L[left]=L[right];// </span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		while(L[left]&lt;=temp&amp;&amp;left&lt;right)//这个循环找右边比temp大的数 </span><br><span class="line">		&#123;</span><br><span class="line">			left=left+1;</span><br><span class="line">		&#125; </span><br><span class="line">		//找到后右边的值换到左边来，左边的值换到右边来 </span><br><span class="line">		L[right]=L[left];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	L[left]=temp; </span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归位</p>
<h3 id="快速排序的基础知识"><a href="#快速排序的基础知识" class="headerlink" title="快速排序的基础知识"></a>快速排序的基础知识</h3><p>快速排序的理解</p>
<blockquote>
<p>对一个列表进行快速排序，首先就是先对列表进行归位操作 ，一般是取列表的第一个元素p进行归位，这时列表被p分成两部分，左边列表的值都比p小，右边列表的值都比p大，然后让左边列表进行归位操作，让右边列表也进行归位操作。以此类推，最终所有元素都依次被归位好。<br>注意<br>一般快排的实现是用递归方式。</p>
</blockquote>
<p>快速排序的举例说明</p>
<blockquote>
<p>例如，对无序表<code>&#123;49，38，65，97，76，13，27，49&#125;</code>进行快速排序，大致过程为：</p>
<ol>
<li>首先从表中选取一个元素，一般是第一个元素，例如选取 49；</li>
<li>然后对49进行归位操作，既将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：<code>&#123;27，38，13，49，65，97，76，49&#125;</code>；</li>
<li>以 49 为支点，将整个无序表分割成了两个部分，分别为无序表1<code>&#123;27，38，13&#125;</code>和无序表2<code>&#123;65，97，76，49&#125;</code>，继续采用此种方法分别对两个无序表进行排序；</li>
<li>无序表1选取第一个元素27进行归位 ，排序后为<code>&#123;13，27，38&#125;</code>，此部分已经有序；无序表2表选取第一个元素 65 进行归位，排序后为<code>&#123;49，65，97，76&#125;</code>；</li>
<li><code>然后无序表3&#123;97，76&#125;</code>，选取第一个元素97，排序后的结果为<code>&#123;76，97&#125;</code>；</li>
<li>通过以上几步的排序，构成有序表：<code>&#123;13，27，38，49，49，65，76，97&#125;</code>；</li>
</ol>
</blockquote>
<p>归为操作的时间复杂度</p>
<blockquote>
<p>n个数，归为一次就得遍历n-1个数，因此归位操作的时间复杂度为<code>O(n)</code></p>
</blockquote>
<h3 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h3><p>快速排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//归位操作的函数，L是列表，left和right分别是表左和表右的下标，返回值是归位后的元素的下标。</span><br><span class="line"> int Partition(int *L,int left,int right)</span><br><span class="line">	int temp= L[left];</span><br><span class="line">	while(left&lt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		//这个循环找右边比temp小的数 </span><br><span class="line">		while(L[right]&gt;=temp&amp;&amp;left&lt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			right=right-1; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//找到后右边的值换到左边来，左边的值换到右边来 </span><br><span class="line">		L[left]=L[right];// </span><br><span class="line"></span><br><span class="line">		//这个循环找右边比temp大的数 </span><br><span class="line">		while(L[left]&lt;=temp&amp;&amp;left&lt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			left=left+1;</span><br><span class="line">		&#125; </span><br><span class="line">		//找到后右边的值换到左边来，左边的值换到右边来 </span><br><span class="line">		L[right]=L[left];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	L[left]=temp; </span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">void QSort(int *L,int left,int right)//快速排序函数 </span><br><span class="line">&#123;</span><br><span class="line">    if (left&lt;right) </span><br><span class="line">	&#123;</span><br><span class="line">       //对第一个元素进行归位操作，然后返回的归位后的下标传给变量mid，既mid记录归位后的下标</span><br><span class="line">        int mid=Partition(L, left, right);</span><br><span class="line">        //对支点左侧的子表进行排序</span><br><span class="line">        QSort(L, left, mid-1);</span><br><span class="line">        //对支点右侧的子表进行排序</span><br><span class="line">        QSort(L, mid+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int L[10]=&#123;5,7,4,6,3,1,2,9,8&#125;;</span><br><span class="line">	QSort(L,0,8);</span><br><span class="line">	for(int i=0;i&lt;9;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;L[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>最好情况时间复杂度和空间复杂度</p>
<blockquote>
<p>![[Pasted image 20230415035248.png]]<br>一般情况下每次对列表进行归位，列表会以归位的数字为中心轴，把列表分为左右两个子表，左边的表数小于右边的数。<br>这里假设，列表有n&#x3D;16个数，且每次列表进行归位操作后，列表被平等的分为左右两个子表，当列表N个数时候，归位一次的需要循环n-1次，也就是时间复杂度为O（n）如上图16个数可分为log2(底数)16(真数)&#x3D; log2(底数)n(真数)&#x3D;4层。每一层所有的列表进行归位操作总共需要循环n次。 所以时间复杂度为<code>O(nlogn)</code><br>这里快速排序是递归调用，递归一层就消耗1空间。由上图可知，递归调用了logn层，所以空间复杂度就为O（logn）</p>
</blockquote>
<p>最坏情况的时间复杂度</p>
<blockquote>
<p>未排序列表为 9 8 7 6 5 4 3 2 1<br>首先对该列表第一个元素进行归位操作得到 1 8 7 6 5 4 3 2 9。</p>
<p>然后递归函数调用，要对列表1 8 7 6 5 4 3 2 进行归位操作，得到8 7 6 5 4 3 2，<br>然后函数递归对列表 8 7 6 5 4 3 2 进行归位。依次下去。<br>可以理解为N个数，每次归位操作，才能把一个数字回归到正确位置。N个数，就得N次归位。第一次归位需要遍历n-1次，第二次(n-2) ,<br>所以最坏情况下时间复杂度为.<br>（n-1）+（n-2）+…..+2，也就是<code>O(n^2)</code><br>每次归位操作，才能把一个数字回归到正确位置。N个数，就得N次归位，也就是得n次递归调用归位函数，递归函数的深度为n所以空间复杂度为<code>O(n)</code>.</p>
</blockquote>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆的向下调整"><a href="#堆的向下调整" class="headerlink" title="堆的向下调整"></a>堆的向下调整</h3><p>堆的向下调整的理解</p>
<blockquote>
<p>假设有一个二叉树，根的左右子树都是堆，但是自身不是堆。此时可以通过一次向下调整，使根节点找到合适的位置，然后使这个二叉树变成堆</p>
</blockquote>
<p>过程</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image031.jpg">假设该二叉树如图</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image032.jpg">首先把根节点取出来。此时判定2的左右节点，比较大的节点（左节点），来做根节点的位置</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image033.jpg">然后判定2能不能做空的节点的位置，不能则在从该空节点的左右节点找较大的一个节点（左结点8）<br>顶上去到空的节点位置</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image034.jpg">然后同上面一样依次判定，2能不能做空节点的位置，不能，再判定空节点的左右节点大小。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image035.jpg">大的一位来做空节点的位置。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image036.jpg"><br>然后判定2能不能做空节点的位置，可以则调整完成。</p>
</blockquote>
<p>堆的向下调整代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//sift函数，即堆的向下调整函数。li为存储二叉树的列表，low二叉树根节点的下标，high二叉树最后一个节点的下标</span><br><span class="line">void sift(int *li,int low,int high)</span><br><span class="line">&#123;	//i指向最开始的根节点的存储位置 </span><br><span class="line">	int i=low;</span><br><span class="line">	//j是i的左孩子下标。</span><br><span class="line">	int j=2*i+1;</span><br><span class="line">	//temp存储根节点的值。 </span><br><span class="line">	int temp=li[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)	 </span><br><span class="line">	&#123;</span><br><span class="line">		//j位置有数，则循环继续。</span><br><span class="line">		if(j&lt;=high)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			//如果右孩子节点存在，且比左孩子节点大，j更改为右孩子的下标。 </span><br><span class="line">			if(j+1&lt;=high&amp;&amp;li[j]&lt;li[j+1]) ++j; </span><br><span class="line">			</span><br><span class="line">			if(li[j]&gt;temp)</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=li[j];</span><br><span class="line">				i=j;</span><br><span class="line">				j=2*i+1;</span><br><span class="line">			&#125; </span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=temp;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//j位置无效，则把temp放在叶子节点上 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			li[i]=temp;break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>堆的向下调整时间复杂度</p>
<blockquote>
<p>因为每执行一次循环，数据就少一半，则堆的向下调整函数最差的时间复杂度为 O(logn)</p>
</blockquote>
<h3 id="堆的构造"><a href="#堆的构造" class="headerlink" title="堆的构造"></a>堆的构造</h3><p>堆的理解</p>
<blockquote>
<p>一种特殊的完全二叉树结构。主要分为大根堆和小根堆</p>
</blockquote>
<p>大根堆的理解</p>
<blockquote>
<p>大根堆一颗完全二叉树，且满足任一节点都比孩子节点大<br>大根堆结构图<br><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image037.jpg"></p>
</blockquote>
<p>小根堆的理解</p>
<blockquote>
<p>小根堆是一颗完全二叉树，且满足任一节点比孩子节点小</p>
<p>小根堆结构图<br><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image038.jpg"></p>
</blockquote>
<p>堆的构造举例说明</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image039.jpg">首先为了方便说明。这里默认对二叉树结点按从上至下、从左到右的顺序编号。依这个编号，我们说该二叉树的最后一个非叶子节点就是3，然后倒数第二个非叶子节点9，倒数第三个非叶子节点就是1，以此类推说明。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image040.jpg">首先找到最后一个非叶子节点。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image041.jpg">然后对这个非叶子节点和他的左右子二叉树构成的二叉树做一次根的向下调整。<br><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image042.jpg">然后找到倒数第二个非叶子节点。因为该子节点已经符合大大根堆的性质，不用调整。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image043.jpg">然后找到倒数第三个的非叶子节点<br>以该节点为根节点构成的二叉树，然后进行一次根的向下调整。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image045.jpg">找到倒数第四个节点<br>以该节点构成的二叉树，进行一次根的向下调整。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image047.jpg">然后就到根节点，对根节点构成的二叉树 进行一次根的向下调整。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image048.jpg"><br>最终就构成了堆</p>
</blockquote>
<p>堆的构造代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//sift函数，即堆的向下调整函数。li为存储二叉树的列表，low二叉树根节点的下标，high二叉树最后一个节点的下标 </span><br><span class="line">void sift(int *li,int low,int high)</span><br><span class="line">&#123;	//i指向最开始的根节点的存储位置 </span><br><span class="line">	int i=low;</span><br><span class="line">	//j是i的左孩子下标。</span><br><span class="line">	int j=2*i+1;</span><br><span class="line">	//temp存储根节点的值。 </span><br><span class="line">	int temp=li[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)	 </span><br><span class="line">	&#123;</span><br><span class="line">		//j位置存在，则循环继续。</span><br><span class="line">		if(j&lt;=high)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			//如果右孩子节点存在，且比左孩子节点大，j更改为右孩子的下标。 </span><br><span class="line">			if(j+1&lt;=high&amp;&amp;li[j]&lt;li[j+1]) ++j; </span><br><span class="line">			if(li[j]&gt;temp)</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=li[j];</span><br><span class="line">				i=j;</span><br><span class="line">				j=2*i+1;</span><br><span class="line">			&#125; </span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=temp;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//j位置不存在，则把temp放在叶子节点上 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			li[i]=temp;break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//构造大根堆的函数,li为列表，n为列表长度 </span><br><span class="line">void dgz(int *li,int n)</span><br><span class="line">&#123; </span><br><span class="line">	//j是最后一个非叶子节点。也就是说为下标为n-1的节点的父节点，也就是最后一个节点的父节点。</span><br><span class="line">	int j=(n-2)/2; </span><br><span class="line">	</span><br><span class="line">	//这里的i为要调整的二叉树的根节点。 </span><br><span class="line">	for(int i=j;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里每次循环执行一次sift,就是将要调整的二叉树调整为堆。 </span><br><span class="line">		//这里拿n-1也就是最后一个节点的下标，作为high，而不是拿要调整的二叉树的最后一个节点的下标作为high。是因为high的作用的本质是在sift函数里的判断j位置是否存在。那么这里可以直接用最后一个节点下标 n-1，依旧可以实现这个作用。就不需要每次循环重新计算要调整的二叉树的最后一个节点的下标。 </span><br><span class="line">		sift(li,i,n-1);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="堆排序的基础知识"><a href="#堆排序的基础知识" class="headerlink" title="堆排序的基础知识"></a>堆排序的基础知识</h3><p>堆排序的理解</p>
<blockquote>
<p>对列表进行堆排序，首先将待排序列构建成大根堆，然后将堆顶元素与堆尾元素交换，此时列表尾部就是已排序列。之后在每一轮排序里，对待排列执行以此堆的向下调整，然后将堆顶元素与堆尾元素交换，以此类推，最终整个序列有序。</p>
<p>具体的说明<br>1.建立大根堆。<br>2.得到堆顶元素，为当前堆的最大元素，放到一个新列表里。<br>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次堆的向下调整重新使堆有序。<br>（将最后一个元素放到堆顶，而不是把原本的根节点的左右节点放到跟堆顶。是为了维持完全二叉树）<br>4.此时堆顶元素为当前堆的最大元素，放到之前的新列表。<br>5.重复步骤3，直到堆变空。原本堆的所有元素都在新列表里排序好了。</p>
</blockquote>
<p>堆排序的举例说明</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image049.jpg">最开始建立堆</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image050.jpg">取出堆顶（此时堆顶是最大元素），放入一个列表里。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image051.jpg">把堆的最后一个元素放到堆顶。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image052.jpg">此时做一次堆的向下调整<br>然后此时堆顶元素又是最大的元素。</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image053.jpg">把堆顶元素取出来在放入列表里</p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image054.jpg"><br>再把最后一个元素放到堆顶。<br>然后再进行堆的一次向下调整。依次循环这些步骤，直到元素全部取出来放入列表里，从大到小排序好。</p>
<p>注意<br>这里我们的演示为了方便理解，我们会在外面开辟一个列表。然后每次堆进行向下调整后，我们就把堆顶元素（当前堆最大的元素）取出来，放到这个列表，然后把堆的最后一个元素放到堆顶，然后再进行堆的向下调整，然后再取出堆顶，再然后放到列表，依次循环，直至列表填满，然后此时列表里也是从小到大的排序好。</p>
<p>但是实际中写代码中，为了减少资源的浪费，我们是不会再开辟一个列表。那么我们每次取出堆顶元素就依然会放到存储该二叉树的列表里。最开始，取堆顶元素，然后让堆顶元素和堆的最后一个元素进行交换。此堆的最后一个节点的位置（堆顶所在的位置）不属于这个堆，然后再标记该节点的上一个节点，即倒数第二个节点为堆的最后一个元素位置。 然后进行一次堆的向下调整，然后此时的堆顶是当前堆的最大元素，然后继续让堆顶和当前堆的最后一个元素进行交换，此时的堆顶就在倒数第二个节点的位置，此时该节点的位置就不属于这个堆 ，并且标记倒数第三个节点的位置为堆的最后一个元素位置  。以此类推，这样就可以减少资源  的浪费，不用在开辟一个列表。</p>
</blockquote>
<h3 id="堆排序的实现"><a href="#堆排序的实现" class="headerlink" title="堆排序的实现"></a>堆排序的实现</h3><p>堆排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//sift函数，即堆的向下调整函数。li为存储二叉树的列表，low二叉树根节点的下标，high二叉树最后一个节点的下标 </span><br><span class="line">void sift(int *li,int low,int high)</span><br><span class="line">&#123;	//i指向最开始的根节点的存储位置 </span><br><span class="line">	int i=low;</span><br><span class="line">	//j是i的左孩子下标。</span><br><span class="line">	int j=2*i+1;</span><br><span class="line">	//temp存储根节点的值。 </span><br><span class="line">	int temp=li[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)	 </span><br><span class="line">	&#123;</span><br><span class="line">		//j位置有数，则循环继续。</span><br><span class="line">		if(j&lt;=high)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			//如果右孩子节点存在，且比左孩子节点大，j更改为右孩子的下标。 </span><br><span class="line">			if(j+1&lt;=high&amp;&amp;li[j]&lt;li[j+1]) ++j; </span><br><span class="line">			if(li[j]&gt;temp)</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=li[j];</span><br><span class="line">				i=j;</span><br><span class="line">				j=2*i+1;</span><br><span class="line">			&#125; </span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=temp;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//j位置无数，则把temp放在叶子节点上 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			li[i]=temp;break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//堆构造函数,li为列表，n为列表长度 </span><br><span class="line">void dgz(int *li,int n)</span><br><span class="line">&#123; </span><br><span class="line">	//j为下标为n-1的节点的父节点，也就是最后一个节点的父节点。j也是最后一个非叶子节点 </span><br><span class="line">	int j=(n-2)/2; </span><br><span class="line">	</span><br><span class="line">	//这里的i为要调整的二叉树的根节点。 </span><br><span class="line">	for(int i=j;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里每次循环执行一次sift,就是将要调整的二叉树调整为堆。 </span><br><span class="line">		//这里拿n-1也就是最后一个节点的下标，作为high，而不是拿要调整的二叉树的最后一个节点的下标作为high。是因为high的作用的本质是在sift函数里的判断j位置是否存在。那么这里可以直接用最后一个节点下标 n-1，依旧可以实现这个作用。就不需要每次循环重新计算要调整的二叉树的最后一个节点的下标。 </span><br><span class="line">		sift(li,i,n-1);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//堆排序函数，li为堆，n为堆长度 </span><br><span class="line">void heap_sort(int *li,int n)</span><br><span class="line">&#123;</span><br><span class="line">	 </span><br><span class="line">	//将列表构造成堆</span><br><span class="line">	dgz(li,n); </span><br><span class="line">	//j为堆最后一个节点的下标。</span><br><span class="line">	for(int j=n-1;j&gt;0;)&#123;</span><br><span class="line">		int temp=li[0];</span><br><span class="line">		li[0]=li[j];</span><br><span class="line">		li[j]=temp;</span><br><span class="line">		</span><br><span class="line">		//这里j指向堆的最后一个节点的下标 </span><br><span class="line">		--j;</span><br><span class="line">		sift(li,0,j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[11]=&#123;5,2,1,6,7,8,9,4,3,10,0&#125;;</span><br><span class="line">	heap_sort(a,11); </span><br><span class="line">	for(int i=0;i&lt;=10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">void sift(int *li,int low,int high)</span><br><span class="line">&#123;	//指向最开始的根节点的存储位置 </span><br><span class="line">	int i=low;</span><br><span class="line">	//j是i的左孩子下标。</span><br><span class="line">	int j=2*i+1;</span><br><span class="line">	//temp存储根节点的值。 </span><br><span class="line">	int temp=li[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)	 </span><br><span class="line">	&#123;</span><br><span class="line">		//j位置有数，则循环继续。</span><br><span class="line">		if(j&lt;=high)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			//如果右孩子节点存在，且比左孩子节点大，j更改为右孩子的下标。 </span><br><span class="line">			if(j+1&lt;=high&amp;&amp;li[j]&lt;li[j+1]) ++j; </span><br><span class="line">			if(li[j]&gt;temp)</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=li[j];</span><br><span class="line">				i=j;</span><br><span class="line">				j=2*i+1;</span><br><span class="line">			&#125; </span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=temp;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//j位置无数，则把temp放在叶子节点上 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			li[i]=temp;break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为每执行一次循环，数据就少一半，则堆的向下调整函数最差的时间复杂度为 O(logn)</span><br><span class="line"></span><br><span class="line">//堆构造函数,li为列表，n为列表长度 </span><br><span class="line">void dgz(int *li,int n)</span><br><span class="line">&#123; </span><br><span class="line">	//j为下标为n-1的节点的父节点，也就是最后一个节点的父节点。j也是最后一个非叶子节点 </span><br><span class="line">	int j=(n-2)/2; </span><br><span class="line">	</span><br><span class="line">	//这里的i为要调整的二叉树的根节点。 </span><br><span class="line">	for(int i=j;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里每次循环执行一次sift,就是将要调整的二叉树调整为堆。 </span><br><span class="line">		//这里拿n-1也就是最后一个节点的下标，作为high，而不是拿要调整的二叉树的最后一个节点的下标作为high。是因为high的作用的本质是在sift函数里的判断j位置是否存在。那么这里可以直接用最后一个节点下标 n-1，依旧可以实现这个作用。就不需要每次循环重新计算要调整的二叉树的最后一个节点的下标。 </span><br><span class="line">		sift(li,i,n-1);</span><br><span class="line">			 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">时间复杂度，循环的次数为(n-2)/2次数，每次都要执行sift函数，所以时间复杂度为O(nlogn)</span><br><span class="line"></span><br><span class="line">//堆排序函数，li为堆，n为堆长度 </span><br><span class="line">void heap_sort(int *li,int n)</span><br><span class="line">&#123;</span><br><span class="line">	//j为堆最后一个节点的下标。 </span><br><span class="line"></span><br><span class="line">	dgz(li,n); </span><br><span class="line">	for(int j=n-1;j&gt;0;)&#123;</span><br><span class="line">		int temp=li[0];</span><br><span class="line">		li[0]=li[j];</span><br><span class="line">		li[j]=temp;</span><br><span class="line">		</span><br><span class="line">		//这里j指向堆的最后一个节点的下标 </span><br><span class="line">		--j;</span><br><span class="line">		sift(li,0,j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">执行n-2次循环,每次循环执行sift函数</span><br><span class="line">堆排序的时间复杂度为O(nlogn)</span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h3><p>归并操作的理解</p>
<blockquote>
<p>假设有一段列表，它可分成两段各自有序列表，但是列表本身不是有序。而将两个各自有序的列表合成一个有序列表该操作就叫归并</p>
</blockquote>
<p>归并操作的举例说明</p>
<blockquote>
<p>![[Pasted image 20230416025135.png]]<br>举例有一列表如图，分为两段，左右两段各自有序。<br>此时新建一个新的空列表。然后对比两段列表的第一个元素，将里面小的放到新的列表里。此时左列表的第一个元素2，右列表的第一个元素1，1小于2.则将1放到新的列表里。</p>
<pre><code>![[Pasted image 20230416025324.png]]
</code></pre>
<p>然后再将右列表的下标往右边移，此时3就为右列表的第一个元素。再让左列表的第一个元素2和右列表的第一个元素3做对比。</p>
<p>![[Pasted image 20230416025415.png]]<br>2小于3，2放到新的列表，并且将左列表下标往右边移，此时左列表的第一个元素就是5.<br>然后重复上面的操作，依次将两个列表的第一个元素，对比，小的进入新的列表里。</p>
<p>![[Pasted image 20230416025930.png]]<br>直到某一个列表所有的数都进入到新的列表里，剩下的另一个列表也就不用继续对比，而是直接进入新列表。如图右列表已经全部进入新的列表里，还剩下左列表。这时候左列表直接全部进入新列表即可。</p>
<p>![[Pasted image 20230416030013.png]]</p>
</blockquote>
<p>这时候两段各自有序的列表，就合并为一个有序的列表。</p>
<p>归并操作的代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//归并操作,li为传入的列表，列表里可以分成左右两段各自为序的列表</span><br><span class="line">//low为左列表的第一个数的下标。mid为左列表最后一个数的下标，此时右列表第一个数的下标就为mid+1，high为右列表最后一个数的下标 </span><br><span class="line">void merge(int *li,int low,int mid,int high )</span><br><span class="line">&#123;</span><br><span class="line">	//构建的新列表，用来存储左右列表对比的数。 </span><br><span class="line">	vector&lt;int&gt; a;</span><br><span class="line">	//i为左列表第一个数下标，j为右列表第一个数下标 </span><br><span class="line">	int i=low;</span><br><span class="line">	int j=mid+1;</span><br><span class="line">	</span><br><span class="line">	//当左右两边列表有数的时候，循环继续。 </span><br><span class="line">	while(i&lt;=mid&amp;&amp;j&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		//左列表第一个数小于右列表第一个数，则左列表第一个数存入新列表，并且往左列表下的标往右边移动 </span><br><span class="line">		if(li[i]&lt;li[j])</span><br><span class="line">		&#123;</span><br><span class="line">			a.push_back(li[i]);i++;</span><br><span class="line">		&#125;</span><br><span class="line">		//右列表列表第一个数小于左列表第一个数，则右列表第一个数存入新列表，并且往右列表的下标往右边移动 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			a.push_back(li[j]);j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	//右列表已经没有，左列表还有值，则将左列表剩下的值都存入新列表。 </span><br><span class="line">	while(i&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		a.push_back(li[i]);i++;</span><br><span class="line">	&#125;</span><br><span class="line">	//左列表已经没有，右列表还有值，则将右列表剩下的值都存入新列表。 </span><br><span class="line">	while(j&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		a.push_back(li[j]);j++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//将新列表的值赋值回原来的列表。 </span><br><span class="line">	int s=low;</span><br><span class="line">	for(int i=0;i&lt;a.size();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		li[s]=a[i];</span><br><span class="line">		++s;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序的基础知识"><a href="#归并排序的基础知识" class="headerlink" title="归并排序的基础知识"></a>归并排序的基础知识</h3><p>归并排序的理解</p>
<blockquote>
<p>将一个列表，在列表里进行分解，分解一次，列表分为两个部分，也就是两个列表。然后不断分解，直到分解到每一个列表里面都只有1个数。<br>然后一个数的列表两两归并合在一起变成两个数的列表。然后已经归并好的两个数的列表，两两之间归并合在一起。以此类推，所有列表从最初分解，最终再合并成一个有序的列表。</p>
</blockquote>
<p>归并排序的举例说明</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image064.jpg"></p>
</blockquote>
<h3 id="归并排序的实现"><a href="#归并排序的实现" class="headerlink" title="归并排序的实现"></a>归并排序的实现</h3><p>归并排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//归并操作,li为传入的列表，列表里可以分成左右两段各自为序的列表</span><br><span class="line">//low为左列表的第一个数的下标。mid为左列表最后一个数的下标，此时右列表第一个数的下标就为mid+1，high为右列表最后一个数的下标 </span><br><span class="line">void merge(int *li,int low,int mid,int high )</span><br><span class="line">&#123;</span><br><span class="line">	//构建的新列表，用来存储左右列表对比的数。 </span><br><span class="line">	vector&lt;int&gt; a;</span><br><span class="line">	//i指向左列表第一个数下标，j指向右列表第一个数下标 </span><br><span class="line">	int i=low;</span><br><span class="line">	int j=mid+1;</span><br><span class="line">	</span><br><span class="line">	//当左右两边列表有数的时候，循环继续。 </span><br><span class="line">	while(i&lt;=mid&amp;&amp;j&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		//左列表第一个数小于右列表第一个数，则左列表第一个数存入新列表，并且往左列表下的标往右边移动 </span><br><span class="line">		if(li[i]&lt;li[j])</span><br><span class="line">		&#123;</span><br><span class="line">			a.push_back(li[i]);i++;</span><br><span class="line">		&#125;</span><br><span class="line">		//右列表列表第一个数小于左列表第一个数，则右列表第一个数存入新列表，并且往右列表的下标往右边移动 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			a.push_back(li[j]);j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	//右列表已经没有，左列表还有值，则将左列表剩下的值都存入新列表。 </span><br><span class="line">	while(i&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		a.push_back(li[i]);i++;</span><br><span class="line">	&#125;</span><br><span class="line">	//左列表已经没有，右列表还有值，则将右列表剩下的值都存入新列表。 </span><br><span class="line">	while(j&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		a.push_back(li[j]);j++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//将新列表的值赋值回原来的列表。 </span><br><span class="line">	int s=low;</span><br><span class="line">	for(int i=0;i&lt;a.size();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		li[s]=a[i];</span><br><span class="line">		++s;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//merge_sort函数是归并排序函数。li为传入的无序列表。low是列表第一个数字的下标，high是最后一个数字的下标</span><br><span class="line">//写merge_sort的时候，可以理解为每次执行merge_sort，其作用是传入的列表分解为两半。然后两半再继续分解。直到分解到一个列表只有1个数了。然后再进行归并操作。 </span><br><span class="line">void merge_sort(int *li,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">	if(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=(low+high)/2;</span><br><span class="line">		merge_sort(li,low,mid);</span><br><span class="line">		merge_sort(li,mid+1,high);</span><br><span class="line">		merge(li,low,mid,high);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[11]=&#123;5,2,1,6,7,8,9,4,3,10,0&#125;;</span><br><span class="line">	merge_sort(a,0,10);</span><br><span class="line">	for(int i=0;i&lt;=10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>归并排序的时间复杂度和空间复杂度</p>
<blockquote>
<p>首先是归并操作的时间复杂度<br>很容易看出来，一次归并操作，需要将分解的两个列表进行遍历，也就是遍历整个列表，所以其时间复杂度是<code>O(n)</code></p>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image065.jpg">由上图和实际代码可以得出，实际分解分解过程是不断递归，没有实际执行什么命令，因此实际执行命令，消耗时间在于归并操作那里。<br>再上图中，有进行归并一共有三层。也就是logn层。每一层进行归并操作的时间复杂度为O（n）,所以整体的时间复杂度为O(nlogn）</p>
<p>每次执行一次归并操作，都需要创建一个新的列表来存放归并的列表。然后归并操作结束后，新的列表被释放。<br>而最后一次的归并操作，也是最大的一次归并操作，就是整个列表的归并操作的时候，这时候需要创建一个和原本列表一样大的新列表。所以空间复杂度就是O（n）。</p>
</blockquote>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="希尔排序的基础知识"><a href="#希尔排序的基础知识" class="headerlink" title="希尔排序的基础知识"></a>希尔排序的基础知识</h3><p>希尔排序的理解</p>
<blockquote>
<p>（升级版插入排序）<br>希尔排序(Shell Sort)是一种分组插入排序算法。<br>首先取一个整数d&#x3D;n&#x2F;2，将元素分为d个组，此时相邻为d的元素为一组，（相邻为d，也就是两个元素之间隔着d-1个元素的为一组），然后对每个组进行直接插入排序;</p>
<p>取第二个整数d&#x3D;d&#x2F;2，重复上述分组排序过程，直到d&#x3D;1，即所有元素在同一组内进行直接插入排序。</p>
<p>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序;最后一趟排序使得所有数据有序。</p>
</blockquote>
<p>希尔排序的举例说明</p>
<blockquote>
<p>![[Pasted image 20230416174233.png]]<br>以上述无序列表为例。列表长度为9，此时d&#x3D;9&#x2F;2&#x3D;4,</p>
<p>![[Pasted image 20230416174423.png]]<br>这时候可以分为四组，把两个元素之间隔着d-1&#x3D;3个元素的为一组</p>
<p>![[Pasted image 20230416174604.png]]<br>然后对各组进行插入排序。  如上图</p>
<p>![[Pasted image 20230416174701.png]]<br>排好之后重新计算d&#x3D;d&#x2F;2&#x3D;2。</p>
<p>![[Pasted image 20230416174718.png]]<br>这时候可以分为2组。</p>
<p>![[Pasted image 20230416174835.png]]<br>然后对每组进行插入排序</p>
<p>![[Pasted image 20230416174908.png]]<br>之后重新计算d&#x3D;d&#x2F;2&#x3D;1<br>![[Pasted image 20230416174933.png]]<br>d&#x3D;1的时候，相隔为0的为一组，也就是对整组进行插入排序。</p>
<p>![[Pasted image 20230416175021.png]]<br>希尔排序结束</p>
</blockquote>
<h3 id="希尔排序的实现"><a href="#希尔排序的实现" class="headerlink" title="希尔排序的实现"></a>希尔排序的实现</h3><p>希尔排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//由插入排序改良 ,a是传入的无序列表，n是列表长度。d是每组相邻量元素之间距离。 </span><br><span class="line">void inser_gap(int a[],int n,int d)</span><br><span class="line">&#123;</span><br><span class="line">	//第一层循环，每次循环就将一个待排序的一个值插入到已排序的序列里，i是待排序的下标</span><br><span class="line">	for(int i=d;i&lt;=n-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		//待排序元素</span><br><span class="line">		int temp=a[i];</span><br><span class="line">		</span><br><span class="line">		//第二层循环，每次循环最开始，j是已排的序列的最大值的下标</span><br><span class="line">		int j=i-d;</span><br><span class="line">		for(;j&gt;=0;)</span><br><span class="line">		&#123;	</span><br><span class="line">			</span><br><span class="line">			if(temp&lt;a[j])</span><br><span class="line">			&#123;	</span><br><span class="line">				a[j+d]=a[j];</span><br><span class="line">				j-=d;</span><br><span class="line">				</span><br><span class="line">			&#125; </span><br><span class="line">			else if(temp&gt;=a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				break;	</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+d]=temp;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//希尔排序函数</span><br><span class="line">void shell_sort(int *li,int n)</span><br><span class="line">&#123;</span><br><span class="line">	int d=n/2;</span><br><span class="line">	while(d)</span><br><span class="line">	&#123;</span><br><span class="line">		inser_gap(li,n,d);</span><br><span class="line">		d=d/2;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主函数，测试函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int a[10001]; </span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	//输入要排序的数组序列 </span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	shell_sort(a,n);</span><br><span class="line">	</span><br><span class="line">	//对排序后的数组进行输出 </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序的时间复杂度</p>
<blockquote>
<p>希尔排序的时间复杂度讨论比较复杂，并且和选取的d序列有关。<br>可以认为选取的d序列不一样，时间复杂度就不一样。<br>我们上面选取的d的序列，d1&#x3D;n&#x2F;2。d2&#x3D;d1&#x2F;2。d3&#x3D;d2&#x2F;2 …..，这时候最差时间复杂度是O（n方）</p>
<p>如果选取d序列是2的k次方-1。 也就是说d是1,3,7,15,31,63,. . 这时候时间复杂度就是O(n的1.5次方)<br>不同d序列的时间复杂度不一样。 至今还有许多学者研究能让时间复杂度更低的d序列</p>
</blockquote>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="计数排序的基础知识"><a href="#计数排序的基础知识" class="headerlink" title="计数排序的基础知识"></a>计数排序的基础知识</h3><p>计数排序的理解</p>
<blockquote>
<p>已知某个列表的里数最大值和最小值，且这些数是整数，那么这时候如果要对这个列表进行排序。就可以不用传统的进行数的对比来排序，而是可以通过计算在数的范围内每个数字出现的次数，来进行排序。这时候时间复杂度就为O（n）</p>
</blockquote>
<p>计数排序的举例说明</p>
<blockquote>
<p>![[Pasted image 20230416182858.png]]<br>假设有一个数的列表，如上图，且我们已知其数的范围是从0-5</p>
<p>![[Pasted image 20230416183618.png]]<br>这时候就新建一个数组，知道数的范围是0-5,那么建立的数组下标范围也是0-5。如图，左边是数组，右边是数组存的值，最开始都为0。<br>比如，列表第一个数是1，则我们就在下标为1的数组加1.第二个数字3，则下标为3的数组加1。以此类推，遍历完整个列表。</p>
<p>![[Pasted image 20230416184014.png]]<br>这样下标为1的数组，里面就记录了在列表里1出现的次数。输出的时候，根据下标小到大来去访问数组。<br>首先看下标为0的数组，值为0，就不用输出0.<br>下标为1的数组值为3，说明1在列表里出现3次，输出三次1.<br>以此类推，就可以输出排序好的列表。</p>
</blockquote>
<h3 id="计数排序的实现"><a href="#计数排序的实现" class="headerlink" title="计数排序的实现"></a>计数排序的实现</h3><p>计数排序的代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits\stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//计数排序，li是未排序的列表。max是列表里最大的值是多少。（这里默认列表值最低为0）.n是列表长度 </span><br><span class="line">void count_sort(int *li,int max,int n)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; a(max+1);	</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[li[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	int s=0;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;=max;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0;j&lt;a[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			li[s]=i;</span><br><span class="line">			++s;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int li[10]=&#123;1,5,0,2,3,5,6,7,9,10&#125;;</span><br><span class="line">	</span><br><span class="line">	count_sort(li,10,10);</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;li[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>计数排序时间复杂度</p>
<blockquote>
<p>计数排序，算法里，第一次循环是遍历一次列表，以此来计数列表里的值。操作了n次。<br>然后的两层for循环，将计数的值存到列表里。也同样是操作了n次。因此时间复杂度为o(n)</p>
</blockquote>
<p> 计数排序的缺陷</p>
<blockquote>
<p>该算法的缺陷就是必须得知道数的范围，且只能是整数。然后还得根据数的范围，来建一个数组，如果数的范围很大，数列表里的数很少，这样会消耗大量的空间。</p>
</blockquote>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="桶排序的基础知识"><a href="#桶排序的基础知识" class="headerlink" title="桶排序的基础知识"></a>桶排序的基础知识</h3><p>桶排序的理解</p>
<blockquote>
<p>在计数排序里，该算法的缺陷就是得根据数的范围，来建数组，如果数的范围很大，数列表里的数很少，这样会消耗大量的空间。桶排序就是将元素分在不同桶里，在对每个桶进行排序。假设，知道一个列表数的范围是0-49。可以分为五个桶，把列表里0-9的数放在桶1，10-19放在桶2，20-29放在桶3，30-39放在桶4，40-49放在桶5。在数字放入的过程中可以用插入排序，让数字再桶内是有序的。又或者先把数字放进桶里，然后再进行排序。</p>
</blockquote>
<p>桶排序的举例说明</p>
<blockquote>
<p>![[Pasted image 20230416191543.png]]<br>首先根据列表的数进行分桶。比如已知列表数的范围是0-49，那么你可以分为5个桶。列表里0-9的数放在桶1，10-19放在桶2，20-29放在桶3，30-39放在桶4，40-49放在桶5。在数字放入桶的过程中要用插入排序。<br>(实际实现的过程中，假如我们按照上面的方式已经分好5个桶了，然后40-49可以放在第五个桶，但是有时候我们不知道最大的数是多少，统一把超过49的数都放在第五个桶。)</p>
<p>列表里的第一个数29放在桶3，第二个数25放在桶3，25比29小，29位置往后移动，25插入到29前面。以此类推，直到所有列表里的数字都分类放到桶里。然后要输出的时候，只要依次从最小的桶开始输出，就是一个有序的列表。</p>
</blockquote>
<p>时间复杂度</p>
<blockquote>
<p>![[Pasted image 20230416191844.png]]</p>
</blockquote>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="基数排序的基础知识"><a href="#基数排序的基础知识" class="headerlink" title="基数排序的基础知识"></a>基数排序的基础知识</h3><p>使用条件</p>
<blockquote>
<p>所有数都是整数，（或者都是字母）</p>
</blockquote>
<p>基数排序的举例说明</p>
<blockquote>
<p>![[Pasted image 20230416193722.png]]<br>首先是分10个桶，数字0放在桶0，数字1放在桶1，数字2放在桶2，以此类推，数字9放在桶9。 然后假设有一个列表，32，13，94，52，17，54，93。</p>
<p>![[Pasted image 20230416195124.png]]<br>首先只看个位数，根据个位数进行分桶，第一个数32的个位数为2放在桶2，第二个数13放在桶3，第三个数94放在桶4，第四个数52放在桶2（这时候不用像桶排序一样进行插入排序，直接放入桶即可）.以此类推，放在桶里.</p>
<p>![[Pasted image 20230416195150.png]]<br>然后将这些数输出来依次从桶里输出出来，32，52，13，93，94，54，17<br>此时可以看出来，列表的数字已经根据个位的大小进行排列。也就是说，只看个位数的话，此时列表的数是从小的到大的排好的。</p>
<p>![[Pasted image 20230416195216.png]]<br>然后对十位进行桶排序<br>然后根据十位进行分桶，第一个数32，放在桶3，第二个数52放在桶5，以此类推。这时候你可以看到同一个桶里放着相同十位数的数字，而又因为我们之前对列表里的个位进行排序过，所以同一个桶里的第一个数的个位数是小小于等于第二个数的个位数，第二个数的个位数小于第三个数的个位数。  也就是说桶里的数只看十位以下（也就是只看十位和个位），也是从小到大排好的</p>
<p>![[Pasted image 20230416195247.png]]<br>然后将这些数输出来依次从桶里输出出来  ， 此时可以看出来，列表的每一个数字，只看十位以下的话，也是从小到大进行排列好了。这就是基数排序</p>
<p>注意<br>如果要排序的数字，最大的一位只有个位，那么只需要根据个位进行分桶，然后放进桶里在输出，即可排序好列表。如果是十位就得先根据个位分桶， 然后放进桶里在输出  ，然后再根据十位分桶，然后放进桶里再输出。以此类推。</p>
</blockquote>
<h3 id="基数排序的实现"><a href="#基数排序的实现" class="headerlink" title="基数排序的实现"></a>基数排序的实现</h3><p>基数排序的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//基数排序，传入未排序列表li ,n为列表长度 </span><br><span class="line">void radix_sort(int *li,int n)</span><br><span class="line">&#123;	</span><br><span class="line">	//首先未排序列表里得最大值max_num;这里略过不写。 </span><br><span class="line">	int max_num; </span><br><span class="line"> </span><br><span class="line">	//it就是用来辅助判断算法最大值是几位。 </span><br><span class="line">	int it=0;</span><br><span class="line">	</span><br><span class="line">	//该循环就是算法里的分桶。第一次循环按个位分桶，第二次循环是按十位分桶，以此类推。最大值是几位数就循环几次</span><br><span class="line">	while (pow(10,it)&lt;=max_num)</span><br><span class="line">	&#123;</span><br><span class="line">		//该数组，分十个桶。 </span><br><span class="line">		int a[10][100]; </span><br><span class="line">		</span><br><span class="line">		//对列表的一次，对列表的每一个值分到不同的桶。 </span><br><span class="line">		//假设有一个值987，第一次循环按个位分桶，这时候要取987里的7.则第一次循环，it=0，987/（10^0）=987,987%10=7。</span><br><span class="line">		//第二次循环要按十位分桶，这时候取987里的8 ，则第二次循环，it=1,987/（10^1）=98, 98%10=8</span><br><span class="line">		//第三次循环要按百位分桶，这时候取987里的9 ，则第三次循环，it=2,987/（10^2）=9, 9%10=9 </span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			//该式子求出了值li[i]该存的桶号s; </span><br><span class="line">			int s; </span><br><span class="line">			s=(li[i]/pow(10,it));s=s%10;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			//下面把li[i]存到桶号为s的数组。这里略 </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		//接下来的for循环是将桶里的数，重新写到列表里，这里不会写，先略。 </span><br><span class="line">		</span><br><span class="line">		++it; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>基数排序的时间复杂度</p>
<blockquote>
<p><code>O(kn)</code>，  k是列表最大值的位数    k次循环，每次循环是O（n），所以是<code>O(kn)</code></p>
</blockquote>
<p>基数排序与快速排序相比</p>
<blockquote>
<p>快排的时间复杂度 是<code>O(nlogn)</code>这里的logn&#x3D;log(2,n)</p>
<p>基数排序的时间复杂度是<code>O(kn)</code>  ，这里的k&#x3D;log(10,max)，max是列表的最大值。也就是说列表里的最值得位数k&lt;log(2,n)得时候基数排序是比快排快。</p>
</blockquote>
<p>基数排序的空间复杂度</p>
<blockquote>
<p><code>O(sn)</code>，s个桶，每个桶的长度跟列表长度一致。</p>
</blockquote>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>稳定排序和不稳定排序的区别</p>
<blockquote>
<p>稳定排序是排序之后，相同数的相对位置不变。<br>比如以三个元素构成一个数据结构。</p>
<p><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :18&#125;</code><br><code>&#123; &#39;name&#39; : &#39;b&#39;, &#39;age &#39; :20&#125;</code><br><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :25&#125;</code><br>这时候对该数据结构组成的列表 按照name进行排序（就是从a-z的顺序排序），这时稳定排序就是，如下，<br><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :18&#125;</code><br><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :25&#125;</code><br><code>&#123; &#39;name&#39; : &#39;b&#39;, &#39;age &#39; :20&#125;</code></p>
<p>两个同样的a都排在前面，但是相对位置不变。而如果是不稳定排序，可能其相对位置就会改变。如下<br><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :25&#125;</code><br><code>&#123;&#39; name&#39; : &#39;a&#39;, &#39;age&#39;  :18&#125;</code><br><code>&#123; &#39;name&#39; : &#39;b&#39;, &#39;age &#39; :20&#125;</code></p>
</blockquote>
<p>确认排序稳定的方法</p>
<blockquote>
<p>如果排序过程一般都是要进行两个数的交换。而如果排序的实现过程是两两之间挨个对比然后交换的，则排序就是稳定排序。如果是中间隔着好几个数，没有挨个对比，直接交换的，往往就是不稳定排序。<br>如冒泡排序 、直接插入排序。就是稳定排序<br>直接选择排序、快排就是不稳定排序。</p>
</blockquote>
<h2 id="排序的总结"><a href="#排序的总结" class="headerlink" title="排序的总结"></a>排序的总结</h2><p>快排三人组总结</p>
<blockquote>
<p>三种排序算法的时间复杂度都是O(nlogn)<br>一般情况下，就运行时间而言:<br>快速排序&lt;归并排序&lt;堆排序</p>
</blockquote>
<p>三种牛逼排序算法的缺点:</p>
<blockquote>
<p>快速排序:极端情况下排序效率低<br>归并排序:需要额外的内存开销<br>堆排序:在快的排序算法中相对较慢</p>
</blockquote>
<p>排序总结图</p>
<blockquote>
<p><img src="/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%99%84%E4%BB%B6/image066.jpg"></p>
</blockquote>
<h1 id="算法问题"><a href="#算法问题" class="headerlink" title="算法问题"></a>算法问题</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>问题描述</p>
<blockquote>
<p>该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置N个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。<br>![[Pasted image 20230416202225.png]]</p>
</blockquote>
<p>盘子数为两个的时候移动步骤</p>
<blockquote>
<p>![[Pasted image 20230416202238.png]]</p>
</blockquote>
<p>盘子数为n个的时候算法步骤</p>
<blockquote>
<p>1 把n-1个盘子由A 移到 B；(C为过渡盘）<br>2 把第n个盘子由 A移到 C；<br>3 把n-1个盘子由B 移到 C；（A为过渡盘）</p>
</blockquote>
<h2 id="topk问题"><a href="#topk问题" class="headerlink" title="topk问题"></a>topk问题</h2><p>topk问题问题描述</p>
<blockquote>
<p>列表里有n个数，找到里面前k个大的数。</p>
</blockquote>
<p>快速排序方案</p>
<blockquote>
<p>先用快速排序对列表进行一个排序，然后取前k个大的数。时间复杂度为O（nlogn）</p>
</blockquote>
<p>lowb排序三人组方案</p>
<blockquote>
<p>选择lowB排序三人组里的其中一个排序方案。然后不完全的使用这个排序。比如用选择排序，一次排序找到当前无序列表里最大的一个数，一次就得对比n次。找到里面前K个大的数，就只用k次排序即可。时间复杂度为O（kn）</p>
</blockquote>
<p>堆排序方案（最优方案）</p>
<blockquote>
<p>![[Pasted image 20230416201153.png]]<br>假设要对该列表取前5个大的数</p>
<p>![[Pasted image 20230416201215.png]]<br>首先取列表5个元素建立一个小根堆，此时堆顶就是第5个大的数。</p>
<p>![[Pasted image 20230416201312.png]]<br>然后遍历该列表后续的元素，依次与堆顶进行对比。小于小根堆则忽略该元素。比如0，小于此时堆顶1则删除。</p>
<p>![[Pasted image 20230416201355.png]]<br>大于该堆顶，就把堆顶删掉，然后将该元素放到堆顶。比如7大于1，则1删除。7放到堆顶</p>
<p>![[Pasted image 20230416201448.png]]<br>然后对这个堆进行一次堆的向下调整。<br>然后所有列表里剩下元素都以此为标准进行遍历对比。遍历完后，则排序完成。</p>
<p>最差的时间复杂度为(nlogk)<br>这里n为列表长度，k为所构建的堆的总元素。</p>
</blockquote>
<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//小根堆版堆的向下调整函数。li为存储二叉树的列表，low二叉树根节点的下标，high二叉树最后一个节点的下标 </span><br><span class="line">void sift(int *li,int low,int high)</span><br><span class="line">&#123;	//i最开始指向根节点的位置 </span><br><span class="line">	int i=low;</span><br><span class="line">	//j是i的左孩子下标。</span><br><span class="line">	int j=2*i+1;</span><br><span class="line">	//temp存储根节点的值。 </span><br><span class="line">	int temp=li[low];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)	 </span><br><span class="line">	&#123;</span><br><span class="line">		//j位置有数，则循环继续。</span><br><span class="line">		if(j&lt;=high)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			//如果右孩子节点存在，且比左孩子节点大，j更改为右孩子的下标。 </span><br><span class="line">			if(j+1&lt;=high&amp;&amp;li[j]&gt;li[j+1]) ++j; </span><br><span class="line">			if(li[j]&lt;temp)</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=li[j];</span><br><span class="line">				i=j;</span><br><span class="line">				j=2*i+1;</span><br><span class="line">			&#125; </span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				li[i]=temp;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//j位置无数，则把temp放在叶子节点上 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			li[i]=temp;break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//小根堆构造函数,li为列表，n为列表长度 </span><br><span class="line">void dgz(int *li,int n)</span><br><span class="line">&#123; </span><br><span class="line">	//j为下标为n-1的节点的父节点，也就是最后一个节点的父节点。j也是最后一个非叶子节点 </span><br><span class="line">	int j=(n-2)/2; </span><br><span class="line">	</span><br><span class="line">	//这里的i为要调整的二叉树的根节点。 </span><br><span class="line">	for(int i=j;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里每次循环执行一次sift,就是将要调整的二叉树调整为堆。 </span><br><span class="line">		//这里拿n-1也就是最后一个节点的下标，作为high，而不是拿要调整的二叉树的最后一个节点的下标作为high。是因为high的作用的本质是在sift函数里的判断j位置是否存在。那么这里可以直接用最后一个节点下标 n-1，依旧可以实现这个作用。就不需要每次循环重新计算要调整的二叉树的最后一个节点的下标。 </span><br><span class="line">		sift(li,i,n-1);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//解决topk问题的函数，li为列表，k表示要找前k个大数，n为列表长度 </span><br><span class="line">void topk(int *li,int k,int n)</span><br><span class="line">&#123;</span><br><span class="line">	//先把列表前k个数构建成小根堆。 </span><br><span class="line">	dgz(li,k); </span><br><span class="line">	//该循环是将列表后面的元素，以此与堆顶进行比较。 </span><br><span class="line">	for(int i=k;i&lt;=n-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//如果后面元素大于堆顶，就将堆顶删去，并且将元素存入堆顶，然后话做一次堆的向下调整。	 </span><br><span class="line">		if(li[i]&gt;li[0])&#123;</span><br><span class="line">			li[0]=li[i];</span><br><span class="line">			sift(li,0,k-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[11]=&#123;5,2,1,6,7,8,9,4,3,10,0&#125;;</span><br><span class="line">	//找出列表前5个大的数。 </span><br><span class="line">	topk(a,5,11);</span><br><span class="line">	for(int i=0;i&lt;=4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/11/potest/">http://example.com/2023/06/11/potest/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/06/11/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E7%9A%84%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">学习目的和学习方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">算法的基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.</span> <span class="toc-text">算法的理解和性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">伪代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%A0%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">伪码的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%A0%81%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.2.</span> <span class="toc-text">伪码的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%9A%84if%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">伪代码的if语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%9A%84whie%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.4.</span> <span class="toc-text">伪代码的whie语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%9A%84for%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.5.</span> <span class="toc-text">伪代码的for语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">时间复杂度的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E8%A7%84%E5%AE%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">时间复杂度的计算规定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">时间复杂度的计算方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">递归算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">4.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">查找基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">4.2.</span> <span class="toc-text">顺序查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">顺序查找的基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">顺序查找的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">4.3.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">二分查找的基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">二分查找的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">排序的基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">冒泡排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">冒泡排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">选择排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">选择排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">插入排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text">插入排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.1.</span> <span class="toc-text">归位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.5.2.</span> <span class="toc-text">快速排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.3.</span> <span class="toc-text">快速排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4"><span class="toc-number">5.6.1.</span> <span class="toc-text">堆的向下调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.6.2.</span> <span class="toc-text">堆的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.6.3.</span> <span class="toc-text">堆排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.4.</span> <span class="toc-text">堆排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.7.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">5.7.1.</span> <span class="toc-text">归并操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.7.2.</span> <span class="toc-text">归并排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.3.</span> <span class="toc-text">归并排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">5.8.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.8.1.</span> <span class="toc-text">希尔排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.2.</span> <span class="toc-text">希尔排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">5.9.</span> <span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.9.1.</span> <span class="toc-text">计数排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.9.2.</span> <span class="toc-text">计数排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.10.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.10.1.</span> <span class="toc-text">桶排序的基础知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">5.11.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.11.1.</span> <span class="toc-text">基数排序的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.11.2.</span> <span class="toc-text">基数排序的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">5.12.</span> <span class="toc-text">排序的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">5.13.</span> <span class="toc-text">排序的总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">算法问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#topk%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">topk问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/11/potest/" title="potest">potest</a><time datetime="2023-06-11T07:34:03.000Z" title="Created 2023-06-11 15:34:03">2023-06-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/11/hello-world/" title="Hello World">Hello World</a><time datetime="2023-06-11T05:50:46.042Z" title="Created 2023-06-11 13:50:46">2023-06-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>